# ğŸ“˜ Telegram Digital Shop Bot (Manual MoMo/Orange Payments)

This is a ready-to-deploy Telegram bot for selling digital products (ebooks, guides, templates).

## ğŸš€ Features
- Sell multiple products
- Show product details & prices
- Accept payments via MTN MoMo / Orange Money (manual verification)
- Buyers upload proof (screenshot/transaction ID)
- Admin confirms/rejects payments with simple commands
- Bot automatically delivers correct product link

---

## âš™ï¸ Setup

1. Clone the repo:
   ```bash
   git clone https://github.com/YOUR-USERNAME/digital-shop-bot.git
   cd digital-shop-botfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, MessageHandler, Filters, CallbackContext

# ==== CONFIG ====
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"   # replace with BotFather token
ADMIN_ID = 123456789                # replace with your Telegram user ID

# Your products
PRODUCTS = {
    "ebook1": {
        "name": "ğŸ“˜ Devenir Rich au Cameroun",
        "price": "2000 XAF",
        "desc": "Guide pratique pour crÃ©er des revenus au Cameroun.",
        "file": "https://yourdomain.com/ebook1.pdf"
    },
    "ebook2": {
        "name": "ğŸ“— 10 Business IdÃ©es Rentables",
        "price": "2500 XAF",
        "desc": "10 idÃ©es faciles pour dÃ©marrer un business rentable.",
        "file": "https://yourdomain.com/ebook2.pdf"
    },
    "ebook3": {
        "name": "ğŸ“™ Secrets du Marketing Digital",
        "price": "3000 XAF",
        "desc": "StratÃ©gies pour vendre et gagner en ligne.",
        "file": "https://yourdomain.com/ebook3.pdf"
    }
}

# Track user selected product
user_selected_product = {}

# ==== HANDLERS ====

def start(update: Update, context: CallbackContext):
    keyboard = []
    for code, prod in PRODUCTS.items():
        keyboard.append([InlineKeyboardButton(f"{prod['name']} - {prod['price']}", callback_data=f"prod_{code}")])
    
    update.message.reply_text(
        "ğŸ‘‹ Bienvenue dans la *Boutique Digitale* !\n\nSÃ©lectionne un produit Ã  acheter :",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

def button(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    chat_id = query.message.chat_id

    if query.data.startswith("prod_"):
        product_code = query.data.split("_")[1]
        product = PRODUCTS[product_code]
        user_selected_product[chat_id] = product_code

        details = (
            f"{product['name']}\n\n"
            f"ğŸ’° Prix: {product['price']}\n\n"
            f"{product['desc']}\n\n"
            "â¡ï¸ Pour acheter:\n"
            "1ï¸âƒ£ Envoie le montant au numÃ©ro suivant:\n"
            "   ğŸ“± MTN MoMo: **670000000**\n"
            "   ğŸ“± Orange Money: **690000000**\n"
            "   RÃ©fÃ©rence: *EBOOK*\n\n"
            "2ï¸âƒ£ AprÃ¨s paiement, envoie la preuve ici."
        )
        keyboard = [[InlineKeyboardButton("âœ… J'ai payÃ©", callback_data="paid")]]
        query.edit_message_text(details, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")

    elif query.data == "paid":
        context.user_data["awaiting_proof"] = True
        query.edit_message_text("ğŸ“¤ Merci ! Envoie maintenant ton *screenshot* ou *ID de transaction* ici.")

def handle_message(update: Update, context: CallbackContext):
    chat_id = update.message.chat_id
    if context.user_data.get("awaiting_proof"):
        proof = update.message.text or "ğŸ“· Screenshot envoyÃ©"
        product_code = user_selected_product.get(chat_id, "unknown")

        # Notify admin
        context.bot.send_message(
            ADMIN_ID,
            f"âš ï¸ Nouvelle preuve de paiement !\n\n"
            f"ğŸ‘¤ Client ID: {chat_id}\n"
            f"ğŸ›’ Produit: {product_code}\n"
            f"ğŸ“„ Preuve: {proof}\n\n"
            f"ğŸ‘‰ Confirme avec: /confirm {chat_id} {product_code}\n"
            f"âŒ Refuser avec: /refuse {chat_id}"
        )

        context.bot.send_message(chat_id, "â³ Merci ! Un administrateur va vÃ©rifier ton paiement.")
        context.user_data["awaiting_proof"] = False

def confirm(update: Update, context: CallbackContext):
    if update.message.chat_id == ADMIN_ID:
        try:
            target_id = int(context.args[0])
            product_code = context.args[1]
            file_link = PRODUCTS[product_code]["file"]
            context.bot.send_message(target_id, f"ğŸ‰ Paiement confirmÃ© ! Voici ton produit ğŸ“˜:\n{file_link}")
            update.message.reply_text("âœ… Produit envoyÃ© avec succÃ¨s.")
        except:
            update.message.reply_text("âš ï¸ Utilisation: /confirm <user_id> <product_code>")

def refuse(update: Update, context: CallbackContext):
    if update.message.chat_id == ADMIN_ID:
        try:
            target_id = int(context.args[0])
            context.bot.send_message(target_id, "âŒ Paiement non validÃ©. VÃ©rifie ton envoi et rÃ©essaie.")
            update.message.reply_text("Refus envoyÃ©.")
        except:
            update.message.reply_text("âš ï¸ Utilisation: /refuse <user_id>")

# ==== MAIN ====
def main():
    updater = Updater(TOKEN, use_context=True)
    dp = updater.dispatcher

    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CallbackQueryHandler(button))
    dp.add_handler(MessageHandler(Filters.text | Filters.photo, handle_message))
    dp.add_handler(CommandHandler("confirm", confirm))
    dp.add_handler(CommandHandler("refuse", refuse))

    updater.start_polling()
    updater.idle()

if __name__ == "__main__":
    main()telegram.ext
